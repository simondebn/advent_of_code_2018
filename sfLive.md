# SF LIVE - LILLE
![enter image description here](https://lille2019.live.symfony.com/images/lille2019/assets/header.jpg)
[Symfony 4.2.4 Realeased Notes](https://symfony.com/blog/symfony-4-2-4-released)
## Keynote - [Fabien Potencier](https://twitter.com/fabpot)
[Slides](https://speakerdeck.com/fabpot/2-new-symfony-components-httpclient-and-mime)
#### HttpClient
[PR for HttpClient](https://github.com/symfony/symfony/pull/30413)
1. **Introduction**
New `HttpClient` contracts and component very simple to use, while still flexible enough to cover most advanced use cases thanks to **streaming** + **laziness**.
Two full implementations are provided:
	1.   `NativeHttpClient`  is based on the native "http" stream wrapper.  
    It's the most portable one but relies on a blocking  `fopen()`.
	2.   `CurlHttpClient`  relies on the curl extension. It supports full  
    concurrency and HTTP/2, including server push.
2. **Client creation + interfaces.** Rely on 2 methods :
	1.  `request()` :  methods on the responses
	2.  `stream()` : Asynchronous requests 

#### MIME 
[PR for MIME](https://github.com/symfony/symfony/pull/30416)
1. **Symfony MIME** : It's goal is to replace *Swift Mailer*. Way less complex & flexible : Usual reworded methods covering 90% of use cases. 
2. **Real "data object"**: Only contains data (no logic). Simple serialization and dynamic headers.
3. **Creating Emails with Twig** : 
	* Class `TemplatedEmail` (extends d'Email) + Class `Renderer` (`render($email)` method). 
	* Native integration with twig : Attachment (`{% do email.atach('@docs/doc.pdf) %}`)
	* HTML + inline CSS integration : `{% filter inline_style() %} + {% filter inline_css() %} + {% filter markdown %}`, 
	* **"Inky"** Integration (Foundation for Email).
	
## REACT & REDUX - [Titouan Galopin](https://twitter.com/titouangalopin)
1. **REACT** All other tools (Vue, Angular etc.) are based on MVC pattern designs and therefore problematic for the model. In general when the model is modified it informs the view and viceversa (*bidirectional data binding*). We talk about mutation (the action of modifying the model). These mutations are complex to set up, reproduce and therefore test.... Hence the objective of REACT which is to find an alternative to mutations the **One way data flow**. We associate each view with a state, we recreate each view with each change of the model. It is a library and not a framework and it is made for IU.
	1. Components: description of a part of the interface that embeds a certain amount of logic that can be reused. Each component has its own state (*data structure*) and a view (how to display the data structure) associated with it (E.g.: with an autocomplete).   The state is actually a `JS` object on which a `render()` function is applied. In this method logic can be implemented. This method will be recalled at each change of state. The `render()` method will allow to build a component tree. In general we have a global component that integrates sub-components, which will contain the business logic of the app. This brings us to the mechanism of **Reconciliation**. It is the application of the changes that correspond to the differences between the two trees generated by the `render()`.
	2. `setState()` : calls REACT's dispatcher and will update the status to finally store it and recall the view.
2. **REDUX** : allows to synchronize all React components. All states are centralized in a single global state for all components of the application. 
	1. Actions
	2. Reducer 
The behavior of the global state is the same as for local components. Changes of local components are made on the global component. We start from the global component (`mapstateToProps()`). The views will dispatch the actions, REDUX will call the reducers who will modify the global state. 
## Complete CI - [Béru](https://twitter.com/jean_beru)
Basically describes the workers/Ci progress we have in TLD. A great tip though was to lad only scenarii's specif features to improve initial loading time
```
Scenario: i want to see an article
    Given the following fixture are loaded:
    """
    App\Document\News:
        news_published:
            title: published news
            content: mazing content
        news_draft:
            title: a draft
            content: the world is not ready yet
    """
```

## Mercure - [Kévin Dunglas](https://twitter.com/dunglas)
[Mercure repo](https://github.com/dunglas/mercure)
[Mercure slides + Presentation](https://dunglas.fr/2019/03/official-push-and-real-time-capabilities-for-symfony-and-api-platform-mercure-protocol/)
**Push** Need for notification from server to client. Real time notification allows to notify users and modify UI. Complicated in PHP as it is an Event not initiated by Client. 
**Mercure** protocol which replaces services such as Websocket.
Fully supported by api-platform 2.4 out of the box. The free binary of the go implementation is able to handle enough connection at the time for TLD usage

## Bundles - [Danielle Kayumbi B.](https://twitter.com/danielleKayumbi)
1. Packages
	1. PHP-CS-Fixer
	2. PHP Sniffer
	3. PhpStan
2. Bundles
	1. grumPhp
	2. Symfony insight
	3. PhpUnit
	4. Behat
	5. Panther
	6. Codeception
	7. AliceBundle
## API Platform - # [Grégoire Hébert](https://twitter.com/gheb_dev)
[Slides](https://speakerdeck.com/gregoirehebert/lecon-numero-139-api-platform-ce-nest-bon-qua-faire-un-poc-faux)
[KeepMeATable Repo](https://github.com/KeepMEATable/api)

## Doctrine - [Romaric Drigon](https://twitter.com/romaricdrigon)
[Slides](https://speakerdeck.com/romaricdrigon/doctrine-en-dehors-des-sentiers-battus)

## Symfony Local Web Server - [Kevin verschaeve](https://twitter.com/keversc)
1. Simplicity: One line installation
2. Logs: logs formatting, can be used for all types of logs
3. Support for several PHP versions: `local:php:list` 
4. Domain name management: `.wip` (can be modified in `proxy.json`, Proxy with web interface)
5. `https` support: `server:ca:install`
6. Docker support 
